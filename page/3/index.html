<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-垂直居中的两个方法及Flex布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/垂直居中的两个方法及Flex布局/" class="article-date">
  <time datetime="2017-03-23T08:02:44.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/垂直居中的两个方法及Flex布局/">垂直居中的两个方法及Flex布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="方法一：transform"><a href="#方法一：transform" class="headerlink" title="方法一：transform"></a>方法一：<code>transform</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">	position:relative;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.child&#123;</div><div class="line">	position: absolute;</div><div class="line">	top: 50%;</div><div class="line">	left: 50%;</div><div class="line">	transform: translate(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法二：使用flex布局"><a href="#方法二：使用flex布局" class="headerlink" title="方法二：使用flex布局"></a>方法二：使用<code>flex</code>布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.parent&#123;</div><div class="line">  display:flex;</div><div class="line">  align-items:center;  //垂直居中</div><div class="line">  justify-content:center;  //水平居中</div><div class="line">&#125;</div><div class="line">.child&#123;</div><div class="line">  //子元素可以设置拉伸系数等</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何一个容器都可以指定为Flex布局，设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>行内元素也可以用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里顺便总结一下flex的常用属性：</p>
<ul>
<li><h5 id="flex-direction：主轴的方向–-gt-水平排列还是垂直排列"><a href="#flex-direction：主轴的方向–-gt-水平排列还是垂直排列" class="headerlink" title="flex-direction：主轴的方向–&gt;   水平排列还是垂直排列"></a>flex-direction：主轴的方向–&gt;   <strong>水平排列还是垂直排列</strong></h5><ul>
<li><code>row</code> <code>row-reverse</code> | <code>column</code> | <code>column-reverse</code></li>
<li>横着排（主轴是水平）起点在左 | 起点在右端 | 竖着排，起点在上边| 起点在下边</li>
</ul>
</li>
<li><h5 id="flex-wrap：如果一行拍不下是否要换行"><a href="#flex-wrap：如果一行拍不下是否要换行" class="headerlink" title="flex-wrap：如果一行拍不下是否要换行"></a>flex-wrap：如果一行拍不下是否要换行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nowrap | wrap | wrap-reverse;</div><div class="line">不换行 | 换行，第一行在上边 |换行，第一行在下边</div></pre></td></tr></table></figure>
</li>
<li><h5 id="flex-flow-简写形式"><a href="#flex-flow-简写形式" class="headerlink" title="flex-flow:  ||  简写形式"></a>flex-flow: <flex-direction> || <flex-wrap> 简写形式</flex-wrap></flex-direction></h5></li>
<li><h5 id="justify-content：在主轴（默认为水平）上的对齐方式"><a href="#justify-content：在主轴（默认为水平）上的对齐方式" class="headerlink" title="justify-content：在主轴（默认为水平）上的对齐方式"></a>justify-content：在主轴（默认为水平）上的对齐方式</h5><ul>
<li><code>flex-start</code>（默认值）：ABCooooooo</li>
<li><code>flex-end</code>：oooooooABC </li>
<li><code>center</code>： oooooABCooooo</li>
<li><code>space-between</code>：AoBoC</li>
<li><code>space-around</code>：oAooBooCo</li>
</ul>
</li>
<li><h5 id="align-items：元素在交叉轴上如何对齐"><a href="#align-items：元素在交叉轴上如何对齐" class="headerlink" title="align-items：元素在交叉轴上如何对齐"></a>align-items：元素在交叉轴上如何对齐</h5><ul>
<li><code>flex-start</code>：交叉轴的起点对齐（<strong>一排元素顶端对齐</strong>）</li>
<li><code>flex-end</code>：交叉轴的终点对齐（<strong>一排元素底端对齐</strong>）</li>
<li><code>center</code>：交叉轴的中点对齐。（<strong>一排元素中线对齐</strong>）</li>
<li><code>baseline</code>: 一排元素的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认）：如果元素未设置高度或设为auto，将占满整个容器的高度。（每个元素都纵向拉伸）</li>
</ul>
</li>
<li><p>align-content</p>
</li>
</ul>
<p>参考<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">阮大大的博客</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/垂直居中的两个方法及Flex布局/" data-id="cj4c4j8s3000kvm2yfc1g6aze" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-清除浮动总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/21/清除浮动总结/" class="article-date">
  <time datetime="2017-03-21T07:07:42.000Z" itemprop="datePublished">2017-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/21/清除浮动总结/">清除浮动总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>假如我们有如下的一个结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">clss</span>=<span class="string">"container"</span> <span class="attr">style</span>=<span class="string">"backgound-color:pink;"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题，浮动<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落，浮动<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当h1和段落都浮动后，父元素<code>container</code>坍塌所以不显示背景色@.@</p>
<blockquote>
<p><strong>通用做法：</strong>使用<code>after</code>伪元素</p>
</blockquote>
<p>给浮动元素的父元素添加一个<code>clearfix</code>选择器：<code>&lt;div class=&quot;container clearfix&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.clearfix:after&#123;</div><div class="line">  content:".";</div><div class="line">  display:block;</div><div class="line">  height:0;    //这三行是为了隐藏content的值</div><div class="line">  clear:both;</div><div class="line">  visibility:hidden;  //注意它和display:none是有区别的,hidden虽然不可见但仍然占据空间</div><div class="line">&#125;</div><div class="line">.clearfix&#123;</div><div class="line">  zoom:1; //如果不考虑IE6/7可以不写（不支持:after伪类）</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述写法相当于在<code>container</code>末尾添加<code>content</code>中的内容，并将其设置为块级元素，高度为0，内容不可见，但任然占据空间，这样就会撑开<code>div</code>元素。隐藏<code>content</code>值还可以稍微改变一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.clearfix:after&#123;</div><div class="line">    content:&quot; &quot;;</div><div class="line">    display:table;</div><div class="line">    clear:both;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个css也许还不是最佳的，这里贴上一篇css hack文章：<a href="https://perishablepress.com/lessons-learned-concerning-the-clearfix-css-hack/" target="_blank" rel="external">Lessons Learned Concerning the Clearfix CSS Hack</a></p>
<blockquote>
<p>一些别的思路</p>
</blockquote>
<ol>
<li>在<code>h1</code>后添加一个空标签：<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>，这样会造成为了清除浮动页面可能有很多无意义的标签，pass！</li>
<li>​给<code>container</code>添加<code>overflow</code></li>
<li><code>container</code>也设置为浮动，如果<code>container</code>外层还有容器，会影响整个布局。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/21/清除浮动总结/" data-id="cj4c4j8sb000ovm2y55cnnrie" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Manifest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/Manifest/" class="article-date">
  <time datetime="2017-03-16T11:45:18.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/Manifest/">HTML5之离线缓存Manifest</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>什么是<code>Manifest</code></strong></p>
<p>简单来说是让应用可以在不联网的情况下也能访问：</p>
<ul>
<li>离线浏览：</li>
<li>更快的速度：读取本地缓存所以访问速度快；</li>
<li>减轻服务器负载：文件缓存后不需要再次请求，只需要请求需要更新的文件。</li>
</ul>
<p><strong>怎么使用</strong></p>
<ol>
<li>需要在想要缓存的每一页都包含该属性：<code>&lt;html manifest=&quot;demo.appcache&quot;&gt;</code>，这样该页面就会被加入<code>application cache</code>中。</li>
<li><code>.manifest</code>格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line">#上面一句必须</div><div class="line">#v1.0.0</div><div class="line">#需要缓存的文件</div><div class="line">CACHE:</div><div class="line">a.js</div><div class="line">b.css</div><div class="line">#不需要缓存的文件</div><div class="line">NETWORK:</div><div class="line">*</div><div class="line">#无法访问页面</div><div class="line">FALLBACK:</div><div class="line">404.html</div></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/Manifest/" data-id="cj4c4j8rf0006vm2yjpksgmm7" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/20/正则表达式/" class="article-date">
  <time datetime="2017-01-20T11:45:18.000Z" itemprop="datePublished">2017-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/20/正则表达式/">正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p><code>\b</code>代表单词的开头或者结尾，也就是单词和空格间的位置，目标字符串的其中一部分，空格隔开。</p>
</li>
<li><p><code>\s</code>匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。</p>
</li>
<li><p><code>\w</code>匹配字母或数字或下划线</p>
</li>
<li><p><code>^</code>字符串开始</p>
</li>
<li><p><code>$</code>字符串结束</p>
<p>​</p>
</li>
<li><p><code>+</code>：一个或者多个，相当于{1，}</p>
</li>
<li><p><code>{2}</code>: 仅2次</p>
</li>
<li><p><code>{1,4}</code>: 左右都包括</p>
</li>
<li><p><code>.</code>：任意一个字符（除换行符之外）</p>
</li>
<li><p><code>*</code>：<code>*</code>前的字符可以连续出现任意次。</p>
</li>
<li><p>用<code>\</code>来转义</p>
</li>
<li><p><code>?</code>: 一次或没有</p>
</li>
<li><p><code>[.?!]</code>匹配标点符号(<code>.</code>或<code>?</code>或<code>!</code>)</p>
</li>
<li><p>分枝条件|：表达式A|表达式B|表达式C，匹配其一即可。</p>
</li>
<li><p><code>(pattern)</code>: 匹配这个格式就可以了</p>
</li>
<li><p><code>(?:pattern)</code>、和上一个差不多，匹配这个pattern格式</p>
</li>
<li><p><code>(?=pattern)</code>、继续向正向找，如果这个后面跟着这个pattern格式，怎么把前面的那个字符拿出来，pattern中的内容不算匹配到的字符</p>
</li>
<li><p><code>(?!pattern)</code>和3相反，后面不跟着这个pattern格式，把前面的字符拿出来</p>
</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul>
<li>精确查找hi：<code>\bhi\b</code></li>
<li>匹配<code>&quot;hi 任意 Lucy&quot;</code>：<code>\bhi\b.*\bLucy\b</code></li>
<li><code>\ba\w*\b</code>：<code>hello aA_______adafafaf</code>(匹配到的是空格后边的一段)</li>
<li>\d+： 匹配一个或者多个连续的数字，后续随便是什么字符都可以</li>
<li>\d+$:  匹配一个或者多个连续的数字，且必须是数字结尾</li>
<li><code>\b\w{6}\b</code>：<code>hello _cs___</code>匹配到的是空格后边的一段</li>
<li><code>\(?</code>: 有或者没有括号</li>
<li>(\d{1,3}.)：子表达式，可以当做一个整体<ul>
<li>(\d{1,3}.){3}：该子表达式重复三次</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/20/正则表达式/" data-id="cj4c4j8sb000nvm2yl3d8mx8g" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-补漏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/20/补漏/" class="article-date">
  <time datetime="2017-01-20T11:45:18.000Z" itemprop="datePublished">2017-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/20/补漏/">补漏</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="适配移动端"><a href="#适配移动端" class="headerlink" title="适配移动端"></a>适配移动端</h2><ol>
<li><p>固定高度，宽度自适应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</div><div class="line">水平方向百分百，flex，定值都可以，不用管手机屏幕的尺寸</div></pre></td></tr></table></figure>
</li>
<li><p>固定宽度，viewport缩放</p>
<p>设计图、页面宽度、viewport width使用一个宽度，浏览器帮我们完成缩放。单位使用px即可。</p>
<p>根据屏幕宽度来动态生成<code>viewport</code>，动态生成缩放比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=640,initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>宽度使用rem</p>
<p>即给<code>&lt;html&gt;</code>设置<code>font-size</code></p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>原型是什么？</strong></p>
<p>在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。</p>
<p><strong>原型链是什么？</strong></p>
<p>JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p>
<p><strong>继承方式：</strong></p>
<ol>
<li><p>原型链</p>
<p><code>Sub.prototype = new Super();</code></p>
<p>缺点：所有子类实例共享继承来的引用属性。</p>
</li>
<li><p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Sub(val)&#123;</div><div class="line">    Super.call(this, val);   // 核心</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：没有用到原型啊，每个子类都有一个新的foo函数，影响性能，浪费内存，冗余。</p>
</li>
<li><p>组合继承（常用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Sub()&#123;</div><div class="line">    Super.call(this);   // 核心</div><div class="line">&#125;</div><div class="line">Sub.prototype = new Super();    // 核心</div></pre></td></tr></table></figure>
<p>构造函数里定义实例属性，原型上绑定函数（实现了函数复用）</p>
<p>优点：</p>
<ul>
<li>调用父类构造方法–&gt; 继承父类的基本属性，并且可以传参</li>
<li>子类原型指向父类实例–&gt;  实现函数复用。</li>
</ul>
<p>缺点：</p>
<ul>
<li>父类构造函数被调用了两次，内存浪费</li>
</ul>
</li>
<li><p>寄生组合继承（优化）</p>
</li>
</ol>
<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>第一步：渲染引擎开始解析html，根据标签构建DOM节点<br>第二步：根据css样式构建渲染树，包括元素的大小、颜色，隐藏的元素不会被构建到该树中。<br>第三步：根据css样式构建布局树，主要是确定元素要显示的位置。<br>第四步：根据前面的信息，绘制渲染树。</p>
<h2 id="cookies，sessionStorage-和-localStorage"><a href="#cookies，sessionStorage-和-localStorage" class="headerlink" title="cookies，sessionStorage 和 localStorage"></a>cookies，sessionStorage 和 localStorage</h2><ul>
<li><p>相同点：存储在客户端</p>
</li>
<li><p><strong>不同点：</strong></p>
<ol>
<li><p>存储大小</p>
<p>cookie数据大小不能超过4k。</p>
<p>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
</li>
<li><p>有效时间</p>
<p>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</p>
<p>cookie  设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
</li>
<li><p>数据与服务器之间的交互方式</p>
<p>cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</p>
<p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
</li>
</ol>
</li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><ol>
<li><p>html：H5新标签在IE9以下的浏览器识别 </p>
<!--[if lt IE 9]>

 <script type="text/javascript" src="js/html5shiv.js"></script>

<![endif]-->
</li>
</ol>
<p>2.css样式的兼容性：</p>
<ul>
<li><p>css的hack问题：主要针对IE的不同版本，不同的浏览器的写法不同       </p>
<p> IE的条件注释hack：       </p>
 <!--[if IE 6]>此处内容只有IE6.0可见<![endif]-->          
 <!--[if IE 7]>此处内容只有IE7.0可见<![endif]-->
</li>
<li><p>被点击过后的超链接不再具有hover和active属性 </p>
<p> 解决办法:按lvha的顺序书写css样式，</p>
<p> “:<strong>l</strong>ink”: a标签还未被访问的状态；</p>
<p> “:<strong>v</strong>isited”: a标签已被访问过的状态；</p>
<p> “:<strong>h</strong>over”: 鼠标悬停在a标签上的状态；</p>
<p> “:<strong>a</strong>ctive”: a标签被鼠标按着时的状态；</p>
</li>
</ul>
<p>3.JavaScript的兼容性</p>
<ul>
<li><p>标准的事件绑定方法函数为addEventListener，但IE下是attachEvent</p>
</li>
<li><p>事件的捕获方式不一致。标准浏览器是由外至内，而IE是由内到外，主流是冒泡。</p>
</li>
<li><p>ajax的实现方式不同，这个我所理解的是获取XMLHttpRequest的不同，IE下是activeXObject</p>
</li>
<li><p>获得DOM节点的父节点、子节点的方式不同</p>
<p>其他浏览器：parentNode  parentNode.childNodes </p>
<p>IE：parentElement parentElement.children</p>
</li>
</ul>
<h2 id="页面是如何呈现的"><a href="#页面是如何呈现的" class="headerlink" title="页面是如何呈现的"></a>页面是如何呈现的</h2><p>1，浏览器首先会查询本机的系统，获取主机名对应的IP地址。</p>
<p>2，若本机查询不到相应的IP地址，则会发起DNS请求，获取主机名对应的IP地址。</p>
<p>3，使用查询到的IP地址，直接访问目标服务器。　</p>
<p>4，浏览器发送HTTP请求。</p>
<p>　　HTTP请求由三部分组成，分别是：请求行、消息报头、请求正文</p>
<p>5， 从请求信息中获得客户机想访问的主机名。</p>
<p>6，从请求信息中获取客户机想要访问的web应用。（web应用程序指提供浏览器访问的程序，简称web应用）</p>
<p>7，从请求信息中获取客户机要访问的web资源。（web资源，即各种文件，图片，视频，文本等）</p>
<p>8，读取相应的主机下的web应用，web资源。</p>
<p>9，用读取到的web资源数据，创建一个HTTP响应。</p>
<p>10，服务器回送HTTP响应。</p>
<p>　　HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p>
<p>11，客户浏览器解析回送的资源，并显示结果。</p>
<h2 id="简述-JS-drag-事件以及模拟-drag-事件的方案"><a href="#简述-JS-drag-事件以及模拟-drag-事件的方案" class="headerlink" title="简述 JS drag 事件以及模拟 drag 事件的方案"></a>简述 JS drag 事件以及模拟 drag 事件的方案</h2><p>一个完整的 drag and drop 流程通常包含以下几个步骤:</p>
<ol>
<li>设置可拖拽目标. 设置属性 draggable=”true” 实现元素的可拖拽.</li>
<li>监听 dragstart 设置拖拽数据</li>
<li>为拖拽操作设置反馈图标 (可选)</li>
<li>设置拖放效果, 如 copy, move, link</li>
<li>设置拖放目标, 默认情况下浏览器阻止所有的拖放操作, 所以需要监听 dragenter 或者 dragover 取消浏览器默认行为使元素可拖放.</li>
<li>监听 drop 事件执行所需操作</li>
</ol>
<p>实现 drag</p>
<ol>
<li>onmousedown + onmousemove → startDrag()</li>
<li>onmouseup → stopDrag()</li>
<li>偏移值，两次事件的鼠标位置记录： e.pageX || e.clientX + scrollX; e.pageY || e.clientY + scrollY;</li>
</ol>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型有两种，W3C和IE盒子模型</p>
<p>W3C定义的盒子模型包括margin、border、padding、content ，元素的width=content的宽度，IE盒子模型与W3C的盒子模型唯一区别就是元素的宽度，元素的width=content+padding+border。</p>
<p>我个人认为IE定义的比较合理，元素的宽度应该包含border（边框）和padding（填充），这个和我们现实生活的盒子是一样的，W3C也认识到自己的问题了，所以在CSS3中新增了一个样式box-sizing，包含两个属性content-box 和 border-box。</p>
<p>对于行内元素，margin-top和margin-bottom无效，margin-left和margin-right有效</p>
<p>对于相邻的块级元素margin-bottom和margin-top 取值方式</p>
<p>1）都是正数： 取最大值</p>
<p>2）都是负数： 取最小值</p>
<p>3）一正一负： 正负相加</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>所有的定位如果left、top、right、bottom属性都为默认值，则为默认定位</p>
<p>absolute定位会脱离文档，浮动起来</p>
<p>absolute定位忽略父元素的padding</p>
<h2 id="样式导入-link-amp-import"><a href="#样式导入-link-amp-import" class="headerlink" title="样式导入 link &amp; import"></a>样式导入 link &amp; import</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;  </div><div class="line"></div><div class="line">&lt;style type=&quot;text/css&quot;&gt;  </div><div class="line">@import &quot;index.css&quot;;  </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>不同：</p>
<ul>
<li>link除了引用样式文件，还可以引用图片等资源文件，而import只引用样式文件</li>
<li>兼容性不同，link不存在兼容性的问题，import在IE5以上支持，是css2.1新增的</li>
<li>在样式表文件可以使用import导入其它的样式表文件，而link不可以</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。<br>注意：<br>import的写法比较多，引号，url（推荐）</li>
</ul>
<h2 id="伪类-amp-伪元素"><a href="#伪类-amp-伪元素" class="headerlink" title="伪类&amp;伪元素"></a>伪类&amp;伪元素</h2><table>
<thead>
<tr>
<th>伪类</th>
<th>伪元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>:active</td>
<td>::first-letter</td>
</tr>
<tr>
<td>:focus</td>
<td>::first-line</td>
</tr>
<tr>
<td>:hover</td>
<td>::before</td>
</tr>
<tr>
<td>:link</td>
<td>::after</td>
</tr>
<tr>
<td>:visited</td>
<td>::selection</td>
</tr>
<tr>
<td>:first-child</td>
</tr>
</tbody>
</table>
<p>伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p>
<p><code>css3</code> 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。</p>
<h2 id="css选择器的优先级"><a href="#css选择器的优先级" class="headerlink" title="css选择器的优先级"></a>css选择器的优先级</h2><p>顺序：!important &gt; style &gt; 权重值</p>
<p><strong>权重规则</strong></p>
<ul>
<li>标签：1</li>
<li>class：10</li>
<li>id：100</li>
</ul>
<h2 id="元素居中"><a href="#元素居中" class="headerlink" title="元素居中"></a>元素居中</h2><blockquote>
<p>元素水平居中</p>
</blockquote>
<ul>
<li><p>行内元素：父元素设置<code>text-align:center;</code></p>
</li>
<li><p>块级元素：<code>maigin:0 auto;</code>（父元素定宽）</p>
</li>
<li><p>浮动元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">position:relative;</div><div class="line">left:50%;   </div><div class="line">transform: translate(-50%,-50%);</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>元素垂直居中</p>
</blockquote>
<ul>
<li><p>行内元素：height和line-hight一样</p>
</li>
<li><p>块级元素：</p>
<ol>
<li><p>父元素<code>display:table-cell;vertical-align:middle;</code></p>
</li>
<li><p>父元素高度确定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.outer&#123;  </div><div class="line">    width: 500px;  </div><div class="line">    height:300px;  </div><div class="line">    line-height: 300px;  +++</div><div class="line">&#125;  </div><div class="line"> .inner&#123;  </div><div class="line">     background: blue;  </div><div class="line">     width: 300px;  </div><div class="line">     height: 100px;  </div><div class="line">     display: inline-block;  +++</div><div class="line">     vertical-align: middle;  +++</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>子元素定宽定高：相对父元素定位：left:50%;right:50%;此时位置在中心向右向左偏移了子元素的宽度或高度的一半，用<code>margin-top:-子元素高度/2</code>,<code>margin-left:-子元素宽度/2</code></p>
</li>
<li><p>子元素不定宽高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.center&#123;  </div><div class="line">    width: 500px;  </div><div class="line">    height:300px;   </div><div class="line">    position: relative;</div><div class="line">&#125;  </div><div class="line"> .inner&#123;</div><div class="line">     width:30%;  </div><div class="line">     height:30%;</div><div class="line">     position: absolute; +++</div><div class="line">     left: 0;  +++</div><div class="line">     right: 0;   +++</div><div class="line">     top:0;   +++</div><div class="line">     bottom: 0;   +++</div><div class="line">     margin: auto;   +++</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
</li>
</ul>
<h2 id="块元素与行内元素"><a href="#块元素与行内元素" class="headerlink" title="块元素与行内元素"></a>块元素与行内元素</h2><ul>
<li>块元素：<code>div/p/ul/ol/dl/table/form/blockquote/h1-h6/</code></li>
<li>行内元素：<code>a/abbr/br/cite/em/i/img/input/label/select/span/strong/sub/sup/textarea/u</code></li>
</ul>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>更严谨的说法其实是叫“闭合浮动”：主要是解决元素浮动后父元素高度塌陷的问题。</p>
<ul>
<li>添加额外标签</li>
<li>给container添加overflow属性</li>
<li>container也浮动</li>
<li>::after伪元素</li>
</ul>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>从页面接收事件的顺序，起初：</p>
<ul>
<li><p>IE：事件冒泡流(主流)</p>
<ul>
<li>button -&gt; body -&gt; document -&gt; window</li>
</ul>
</li>
<li><p>事件流，包括三个阶段：</p>
<ul>
<li><p>事件捕获阶段</p>
<ul>
<li>addEventListener最后一个参数，true代表事件捕获模式，<strong>false表示事件冒泡模式</strong>(默认)。</li>
</ul>
</li>
<li><p>处于目标阶段</p>
<ul>
<li>事件到了具体元素，被看成冒泡阶段的一部分</li>
</ul>
</li>
<li><p>事件冒泡阶段</p>
<p>可以被阻止：</p>
<ol>
<li>IE模型，<code>window.event.cancelBubble = true</code></li>
<li>w3c模型：<code>e.stopPropagation()</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="DOM0级、DOM2事件处理程序"><a href="#DOM0级、DOM2事件处理程序" class="headerlink" title="DOM0级、DOM2事件处理程序"></a>DOM0级、DOM2事件处理程序</h3><ol>
<li><p>Dom0级：事件流的冒泡阶段被处理</p>
<p><code>btn.onclick=function(){};</code></p>
</li>
<li><p>Dom2级：true捕获</p>
<p><code>addEventListener(事件名，处理函数，bool)</code>和<code>removeEventListener(事件名，处理函数，bool)</code></p>
<p>主流都是在冒泡阶段调用事件处理程序，所以默认为<code>false</code>, <code>true</code>表示捕获阶段调用。</p>
</li>
</ol>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>将事件委托到父元素或祖先元素来实现。</p>
<ol>
<li><p>一一添加事件监听麻烦</p>
<p>当我们想要给一系列元素添加一些事件，又不想对每个元素一一去添加事件监听时，可以采用委托来实现。</p>
</li>
<li><p>委托可以有效的提高页面性能。</p>
<p>给大量元素都添加事件监听时，会照成页面过多的性能损耗，所以碰到要给一系列元素添加事件时，建议采用事件委托，</p>
</li>
</ol>
<h2 id="CSS中可以-不可以被继承的属性"><a href="#CSS中可以-不可以被继承的属性" class="headerlink" title="CSS中可以 / 不可以被继承的属性"></a>CSS中可以 / 不可以被继承的属性</h2><ul>
<li><p><strong>字体属性：</strong></p>
<p><code>font-family, font-size, font-style, font-variant, font-weight, font</code></p>
</li>
<li><p><strong>文本属性</strong>：</p>
<p><code>word-spacing letter-spacing text-align text-transform text-indent line-height</code>可以继承</p>
<p><em>text-decoration vertical-align不可继承</em></p>
</li>
<li><p><strong>颜色背景属性</strong>：</p>
<p><code>color</code>可以继承</p>
<p><code>background</code>不可继承</p>
</li>
<li><p><strong>边框属性：</strong></p>
<p><code>border</code>不可以继承</p>
<p><code>(border-top border-right border-bottom border-left)(border-width border-style border-color)</code></p>
</li>
<li><p><strong>定位和布局属性：</strong></p>
<p><code>margin padding width height float clear position left top overflow z-index display</code>不可以继承</p>
</li>
<li><p><strong>列表属性：</strong></p>
<p><code>list-style-image, list-style-position,list-style-type, list-style</code>可以继承</p>
</li>
<li><p><strong>所有元素可继承</strong>： </p>
<p><code>visibility和cursor</code></p>
</li>
</ul>
<h2 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CSS3实现圆角（border-radius），阴影（box-shadow），</div><div class="line">对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</div><div class="line">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</div><div class="line">增加了更多的CSS选择器  多背景 rgba </div><div class="line">在CSS3中唯一引入的伪元素是::selection.</div><div class="line">媒体查询，多栏布局(columns属性) </div><div class="line">border-image</div></pre></td></tr></table></figure>
<h2 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</h2><p>HTML5 主要是关于图像，位置，存储，多任务等功能的增加。</p>
<ul>
<li><p>拖拽释放(Drag and drop) API </p>
<p>语义化更好的内容标签（header,nav,footer,aside,article,section）</p>
<p>音频、视频API(audio,video)</p>
<p>画布(Canvas) API</p>
<p>地理(Geolocation) API</p>
<p>本地离线存储 localStorage /sessionStorage</p>
<p>表单控件，calendar、date、time、email、url、search  </p>
<p>新的技术webworker, websocket, Geolocation</p>
</li>
<li><p>移除的元素</p>
<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p>
<p>对可用性产生负面影响的元素：frame，frameset，noframes；</p>
</li>
<li><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签。浏览器支持新标签后，还需要添加标签默认的样式：</p>
</li>
<li><p>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</p>
 <!--[if lt IE 9]> 
 <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script> 
 <![endif]--> 
</li>
</ul>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol>
<li><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</li>
<li>​</li>
</ol>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li><p>修改window.domain 方式(同源跨域)</p>
</li>
<li><p>jsonp</p>
<p>利用js脚本的src属性发送一个get请求，如果没有jjsonp，会正常返回一个json数据，利用jsonp服务端接受callback参数，用该参数包装要返回的json数据，如果我们的页面正好有一个callback的函数，一返回结果就会执行该函数。</p>
</li>
<li><p>postmessage</p>
<p>HTML5新特性，可以完成jsonp无法完成的post请求</p>
<p>A给B跨域发送：<code>iframeWin.postMessage(&#39;hello world!&#39;,&quot;*&quot;);</code>//限制接收窗体的url</p>
<p>B监听发送来的消息：<code>window.addEventListener(&#39;message&#39;, onMessage, false);</code></p>
</li>
<li><p>代理</p>
</li>
<li><p>cors</p>
<p><strong>Access-Control-Allow-Origin</strong></p>
</li>
</ol>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul>
<li><p>同步任务都在主线程上执行，形成一个执行栈。</p>
</li>
<li><p>异步任务不进入主线程，而是进入任务队列</p>
</li>
<li><p>同步——》异步——》回调</p>
<p>先执行同步代码，for，但不给settimeout传参（回调最后执行），等for循环执行完传参。</p>
<p>回调放进消息队列。每执行一次for循环，就放一个settimeout到消息队列中排队。同步执行完了再去调用消息队列中的回调方法。</p>
</li>
</ul>
<h2 id="web性能优化"><a href="#web性能优化" class="headerlink" title="web性能优化"></a>web性能优化</h2><ol>
<li><p>减少http请求：合并css、js，合并图片（css sprites），图片多的时候用延迟加载lazyload（判断在视口中的位置，给img标签填充src属性，jquery有lazyload插件）</p>
</li>
<li><p>开启Gzip。是一种压缩技术，可以将资源在服务端进行压缩，然后发送给浏览器后再进行解压，这种方式会降低传输大小，提高网页加载性能。</p>
</li>
<li><p>按需加载资源。</p>
<p>资源（特别是图片）的按需加载或者说<em>惰性加载</em>，可以有助于你的 Web 应用在整体上获得更好的性能。对于使用大量图片的页面来说惰性加载有着显著的三个好处：</p>
<ul>
<li>减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间）</li>
<li>减少浏览器的内存使用率（更少的图片，更少的内存）</li>
<li>减少服务器端的负载</li>
</ul>
</li>
<li><p>少操作dom，dom的变化（改变文字大小，窗口大小，内容改变，属性改变等）可能会让浏览器重新计算元素的宽高，会引起页面reflow也就是重新布局，过于频繁cpu使用就会上涨</p>
<p>通过设置class，包含有动画属性的元素是否可以采用absolute或者fixed的布局，少进行对dom的查询修改，尤其是少进行对dom的循环操作，总之就是减少reflow的影响范围。</p>
<p>reflow何时发生：</p>
<p>1、添加或者删除可见的DOM元素；</p>
<p>2、元素位置改变；</p>
<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>
<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>
<p>5、页面渲染初始化；</p>
<p>6、浏览器窗口尺寸改变——resize事件发生时；</p>
<p>很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，</p>
<p><strong>直接改变className</strong></p>
<p><strong>不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存</strong></p>
<p>reflow的开销大于repaint,所以用marginLeft, width ,height等属性改变dom时我们要注意减少影响的范围。基本原则就是，把动画元素用position:absolute踢出文档流，这样R&amp;R就限制在了absolute元素的子节点。</p>
</li>
<li><p>用json进行数据交换：js的原生格式，轻量，相比xml的数据体积要小。处理json:eval()和json.parse()</p>
</li>
<li><p>html的语义化，正确使用常用标签：css没有成功加载时呈现好的内容结构；利于SEO</p>
</li>
<li><p>css选择器，从右向左匹配，!important标签、伪类，类型选择器</p>
</li>
<li><p>CDN：网络各处都放置了节点服务器，根据网络流量、各节点负载，到用户的距离把用户的请求重定向到离用户最近的服务节点上。</p>
</li>
<li><p>js和css压缩：减少文件体积</p>
</li>
</ol>
<h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>衡量方法：排序前两个相等的数排序后的位置是否颠倒。如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<ol>
<li><p>冒泡、插入、归并</p>
<p>稳定</p>
</li>
<li><p>选择排序、快排</p>
<p>每个位置选当前元素最小的。不稳定</p>
</li>
</ol>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Copy(p, c) &#123;</div><div class="line">      var c = c || &#123;&#125;;</div><div class="line">      for (var i in p) &#123;</div><div class="line">      　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">      　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">      　　　　　Copy(p[i], c[i]);</div><div class="line">      　　&#125; else &#123;</div><div class="line">      　　　　　c[i] = p[i];</div><div class="line">      　　&#125;</div><div class="line">      &#125;</div><div class="line">      return c;</div><div class="line">&#125; </div><div class="line">var a=&#123;&#125;;  </div><div class="line">  a.key2 = [&apos;小辉&apos;,&apos;小辉&apos;];</div><div class="line">  var b=&#123;&#125;;</div><div class="line">  b = Copy(a,b);        </div><div class="line">  b.key2.push(&quot;大辉&quot;);</div><div class="line">  alert(b.key2);    //小辉，小辉，大辉</div><div class="line">  alert(a.key2);    //小辉，小辉</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/20/补漏/" data-id="cj4c4j8se000svm2yypsfwrqa" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基础补漏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/14/基础补漏/" class="article-date">
  <time datetime="2017-01-14T14:58:03.000Z" itemprop="datePublished">2017-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/14/基础补漏/">基础补漏</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="适配移动端"><a href="#适配移动端" class="headerlink" title="适配移动端"></a>适配移动端</h2><ol>
<li><p>固定高度，宽度自适应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</div><div class="line">水平方向百分百，flex，定值都可以，不用管手机屏幕的尺寸</div></pre></td></tr></table></figure>
</li>
<li><p>固定宽度，viewport缩放</p>
<p>设计图、页面宽度、viewport width使用一个宽度，浏览器帮我们完成缩放。单位使用px即可。</p>
<p>根据屏幕宽度来动态生成<code>viewport</code>，动态生成缩放比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=640,initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>宽度使用rem</p>
<p>即给<code>&lt;html&gt;</code>设置<code>font-size</code></p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>原型是什么？</strong></p>
<p>在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。</p>
<p><strong>原型链是什么？</strong></p>
<p>JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p>
<p><strong>继承方式：</strong></p>
<ol>
<li><p>原型链</p>
<p><code>Sub.prototype = new Super();</code></p>
<p>缺点：所有子类实例共享继承来的引用属性。</p>
</li>
<li><p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Sub(val)&#123;</div><div class="line">    Super.call(this, val);   // 核心</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：没有用到原型啊，每个子类都有一个新的foo函数，影响性能，浪费内存，冗余。</p>
</li>
<li><p>组合继承（常用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Sub()&#123;</div><div class="line">    Super.call(this);   // 核心</div><div class="line">&#125;</div><div class="line">Sub.prototype = new Super();    // 核心</div></pre></td></tr></table></figure>
<p>构造函数里定义实例属性，原型上绑定函数（实现了函数复用）</p>
<p>优点：</p>
<ul>
<li>调用父类构造方法–&gt; 继承父类的基本属性，并且可以传参</li>
<li>子类原型指向父类实例–&gt;  实现函数复用。</li>
</ul>
<p>缺点：</p>
<ul>
<li>父类构造函数被调用了两次，内存浪费</li>
</ul>
</li>
<li><p>寄生组合继承（优化）</p>
</li>
</ol>
<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>第一步：渲染引擎开始解析html，根据标签构建DOM节点<br>第二步：根据css样式构建渲染树，包括元素的大小、颜色，隐藏的元素不会被构建到该树中。<br>第三步：根据css样式构建布局树，主要是确定元素要显示的位置。<br>第四步：根据前面的信息，绘制渲染树。</p>
<h2 id="cookies，sessionStorage-和-localStorage"><a href="#cookies，sessionStorage-和-localStorage" class="headerlink" title="cookies，sessionStorage 和 localStorage"></a>cookies，sessionStorage 和 localStorage</h2><ul>
<li><p>相同点：存储在客户端</p>
</li>
<li><p><strong>不同点：</strong></p>
<ol>
<li><p>存储大小</p>
<p>cookie数据大小不能超过4k。</p>
<p>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
</li>
<li><p>有效时间</p>
<p>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</p>
<p>cookie  设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
</li>
<li><p>数据与服务器之间的交互方式</p>
<p>cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</p>
<p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
</li>
</ol>
</li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><ol>
<li><p>html：H5新标签在IE9以下的浏览器识别 </p>
<!--[if lt IE 9]>

 <script type="text/javascript" src="js/html5shiv.js"></script>

<![endif]-->
</li>
</ol>
<p>2.css样式的兼容性：</p>
<ul>
<li><p>css的hack问题：主要针对IE的不同版本，不同的浏览器的写法不同       </p>
<p>IE的条件注释hack：       </p>
<!--[if IE 6]>此处内容只有IE6.0可见<![endif]-->          
<!--[if IE 7]>此处内容只有IE7.0可见<![endif]-->
</li>
<li><p>被点击过后的超链接不再具有hover和active属性 </p>
<p>解决办法:按lvha的顺序书写css样式，</p>
<p>“:<strong>l</strong>ink”: a标签还未被访问的状态；</p>
<p>“:<strong>v</strong>isited”: a标签已被访问过的状态；</p>
<p>“:<strong>h</strong>over”: 鼠标悬停在a标签上的状态；</p>
<p>“:<strong>a</strong>ctive”: a标签被鼠标按着时的状态；</p>
</li>
</ul>
<p>3.JavaScript的兼容性</p>
<ul>
<li><p>标准的事件绑定方法函数为addEventListener，但IE下是attachEvent</p>
</li>
<li><p>事件的捕获方式不一致。标准浏览器是由外至内，而IE是由内到外，主流是冒泡。</p>
</li>
<li><p>ajax的实现方式不同，这个我所理解的是获取XMLHttpRequest的不同，IE下是activeXObject</p>
</li>
<li><p>获得DOM节点的父节点、子节点的方式不同</p>
<p>其他浏览器：parentNode  parentNode.childNodes </p>
<p>IE：parentElement parentElement.children</p>
</li>
</ul>
<h2 id="页面是如何呈现的"><a href="#页面是如何呈现的" class="headerlink" title="页面是如何呈现的"></a>页面是如何呈现的</h2><p>1，浏览器首先会查询本机的系统，获取主机名对应的IP地址。</p>
<p>2，若本机查询不到相应的IP地址，则会发起DNS请求，获取主机名对应的IP地址。</p>
<p>3，使用查询到的IP地址，直接访问目标服务器。　</p>
<p>4，浏览器发送HTTP请求。</p>
<p>　　HTTP请求由三部分组成，分别是：请求行、消息报头、请求正文</p>
<p>5， 从请求信息中获得客户机想访问的主机名。</p>
<p>6，从请求信息中获取客户机想要访问的web应用。（web应用程序指提供浏览器访问的程序，简称web应用）</p>
<p>7，从请求信息中获取客户机要访问的web资源。（web资源，即各种文件，图片，视频，文本等）</p>
<p>8，读取相应的主机下的web应用，web资源。</p>
<p>9，用读取到的web资源数据，创建一个HTTP响应。</p>
<p>10，服务器回送HTTP响应。</p>
<p>　　HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p>
<p>11，客户浏览器解析回送的资源，并显示结果。</p>
<h2 id="简述-JS-drag-事件以及模拟-drag-事件的方案"><a href="#简述-JS-drag-事件以及模拟-drag-事件的方案" class="headerlink" title="简述 JS drag 事件以及模拟 drag 事件的方案"></a>简述 JS drag 事件以及模拟 drag 事件的方案</h2><p>一个完整的 drag and drop 流程通常包含以下几个步骤:</p>
<ol>
<li>设置可拖拽目标. 设置属性 draggable=”true” 实现元素的可拖拽.</li>
<li>监听 dragstart 设置拖拽数据</li>
<li>为拖拽操作设置反馈图标 (可选)</li>
<li>设置拖放效果, 如 copy, move, link</li>
<li>设置拖放目标, 默认情况下浏览器阻止所有的拖放操作, 所以需要监听 dragenter 或者 dragover 取消浏览器默认行为使元素可拖放.</li>
<li>监听 drop 事件执行所需操作</li>
</ol>
<p>实现 drag</p>
<ol>
<li>onmousedown + onmousemove → startDrag()</li>
<li>onmouseup → stopDrag()</li>
<li>偏移值，两次事件的鼠标位置记录： e.pageX || e.clientX + scrollX; e.pageY || e.clientY + scrollY;</li>
</ol>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型有两种，W3C和IE盒子模型</p>
<p>W3C定义的盒子模型包括margin、border、padding、content ，元素的width=content的宽度，IE盒子模型与W3C的盒子模型唯一区别就是元素的宽度，元素的width=content+padding+border。</p>
<p>我个人认为IE定义的比较合理，元素的宽度应该包含border（边框）和padding（填充），这个和我们现实生活的盒子是一样的，W3C也认识到自己的问题了，所以在CSS3中新增了一个样式box-sizing，包含两个属性content-box 和 border-box。</p>
<p>对于行内元素，margin-top和margin-bottom无效，margin-left和margin-right有效</p>
<p>对于相邻的块级元素margin-bottom和margin-top 取值方式</p>
<p>1）都是正数： 取最大值</p>
<p>2）都是负数： 取最小值</p>
<p>3）一正一负： 正负相加</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>所有的定位如果left、top、right、bottom属性都为默认值，则为默认定位</p>
<p>absolute定位会脱离文档，浮动起来</p>
<p>absolute定位忽略父元素的padding</p>
<h2 id="样式导入-link-amp-import"><a href="#样式导入-link-amp-import" class="headerlink" title="样式导入 link &amp; import"></a>样式导入 link &amp; import</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;  </div><div class="line"></div><div class="line">&lt;style type=&quot;text/css&quot;&gt;  </div><div class="line">@import &quot;index.css&quot;;  </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>不同：</p>
<ul>
<li>link除了引用样式文件，还可以引用图片等资源文件，而import只引用样式文件</li>
<li>兼容性不同，link不存在兼容性的问题，import在IE5以上支持，是css2.1新增的</li>
<li>在样式表文件可以使用import导入其它的样式表文件，而link不可以</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。<br>注意：<br>import的写法比较多，引号，url（推荐）</li>
</ul>
<h2 id="伪类-amp-伪元素"><a href="#伪类-amp-伪元素" class="headerlink" title="伪类&amp;伪元素"></a>伪类&amp;伪元素</h2><table>
<thead>
<tr>
<th>伪类</th>
<th>伪元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>:active</td>
<td>::first-letter</td>
</tr>
<tr>
<td>:focus</td>
<td>::first-line</td>
</tr>
<tr>
<td>:hover</td>
<td>::before</td>
</tr>
<tr>
<td>:link</td>
<td>::after</td>
</tr>
<tr>
<td>:visited</td>
<td>::selection</td>
</tr>
<tr>
<td>:first-child</td>
</tr>
</tbody>
</table>
<p>伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p>
<p><code>css3</code> 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。</p>
<h2 id="css选择器的优先级"><a href="#css选择器的优先级" class="headerlink" title="css选择器的优先级"></a>css选择器的优先级</h2><p>顺序：!important &gt; style &gt; 权重值</p>
<p><strong>权重规则</strong></p>
<ul>
<li>标签：1</li>
<li>class：10</li>
<li>id：100</li>
</ul>
<h2 id="元素居中"><a href="#元素居中" class="headerlink" title="元素居中"></a>元素居中</h2><blockquote>
<p>元素水平居中</p>
</blockquote>
<ul>
<li><p>行内元素：父元素设置<code>text-align:center;</code></p>
</li>
<li><p>块级元素：<code>maigin:0 auto;</code>（父元素定宽）</p>
</li>
<li><p>浮动元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">position:relative;</div><div class="line">left:50%;   </div><div class="line">transform: translate(-50%,-50%);</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>元素垂直居中</p>
</blockquote>
<ul>
<li><p>行内元素：height和line-hight一样</p>
</li>
<li><p>块级元素：</p>
<ol>
<li><p>父元素<code>display:table-cell;vertical-align:middle;</code></p>
</li>
<li><p>父元素高度确定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.outer&#123;  </div><div class="line">    width: 500px;  </div><div class="line">    height:300px;  </div><div class="line">    line-height: 300px;  +++</div><div class="line">&#125;  </div><div class="line"> .inner&#123;  </div><div class="line">     background: blue;  </div><div class="line">     width: 300px;  </div><div class="line">     height: 100px;  </div><div class="line">     display: inline-block;  +++</div><div class="line">     vertical-align: middle;  +++</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>子元素定宽定高：相对父元素定位：left:50%;right:50%;此时位置在中心向右向左偏移了子元素的宽度或高度的一半，用<code>margin-top:-子元素高度/2</code>,<code>margin-left:-子元素宽度/2</code></p>
</li>
<li><p>子元素不定宽高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.center&#123;  </div><div class="line">    width: 500px;  </div><div class="line">    height:300px;   </div><div class="line">    position: relative;</div><div class="line">&#125;  </div><div class="line"> .inner&#123;</div><div class="line">     width:30%;  </div><div class="line">     height:30%;</div><div class="line">     position: absolute; +++</div><div class="line">     left: 0;  +++</div><div class="line">     right: 0;   +++</div><div class="line">     top:0;   +++</div><div class="line">     bottom: 0;   +++</div><div class="line">     margin: auto;   +++</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
</li>
</ul>
<h2 id="块元素与行内元素"><a href="#块元素与行内元素" class="headerlink" title="块元素与行内元素"></a>块元素与行内元素</h2><ul>
<li>块元素：<code>div/p/ul/ol/dl/table/form/blockquote/h1-h6/</code></li>
<li>行内元素：<code>a/abbr/br/cite/em/i/img/input/label/select/span/strong/sub/sup/textarea/u</code></li>
</ul>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>更严谨的说法其实是叫“闭合浮动”：主要是解决元素浮动后父元素高度塌陷的问题。</p>
<ul>
<li>添加额外标签</li>
<li>给container添加overflow属性</li>
<li>container也浮动</li>
<li>::after伪元素</li>
</ul>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>从页面接收事件的顺序，起初：</p>
<ul>
<li><p>IE：事件冒泡流(主流)</p>
<ul>
<li>button -&gt; body -&gt; document -&gt; window</li>
</ul>
</li>
<li><p>事件流，包括三个阶段：</p>
<ul>
<li><p>事件捕获阶段</p>
<ul>
<li>addEventListener最后一个参数，true代表事件捕获模式，<strong>false表示事件冒泡模式</strong>(默认)。</li>
</ul>
</li>
<li><p>处于目标阶段</p>
<ul>
<li>事件到了具体元素，被看成冒泡阶段的一部分</li>
</ul>
</li>
<li><p>事件冒泡阶段</p>
<p>可以被阻止：</p>
<ol>
<li>IE模型，<code>window.event.cancelBubble = true</code></li>
<li>w3c模型：<code>e.stopPropagation()</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="DOM0级、DOM2事件处理程序"><a href="#DOM0级、DOM2事件处理程序" class="headerlink" title="DOM0级、DOM2事件处理程序"></a>DOM0级、DOM2事件处理程序</h3><ol>
<li><p>Dom0级：事件流的冒泡阶段被处理</p>
<p><code>btn.onclick=function(){};</code></p>
</li>
<li><p>Dom2级：true捕获</p>
<p><code>addEventListener(事件名，处理函数，bool)</code>和<code>removeEventListener(事件名，处理函数，bool)</code></p>
<p>主流都是在冒泡阶段调用事件处理程序，所以默认为<code>false</code>, <code>true</code>表示捕获阶段调用。</p>
</li>
</ol>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>将事件委托到父元素或祖先元素来实现。</p>
<ol>
<li><p>一一添加事件监听麻烦</p>
<p>当我们想要给一系列元素添加一些事件，又不想对每个元素一一去添加事件监听时，可以采用委托来实现。</p>
</li>
<li><p>委托可以有效的提高页面性能。</p>
<p>给大量元素都添加事件监听时，会照成页面过多的性能损耗，所以碰到要给一系列元素添加事件时，建议采用事件委托，</p>
</li>
</ol>
<h2 id="CSS中可以-不可以被继承的属性"><a href="#CSS中可以-不可以被继承的属性" class="headerlink" title="CSS中可以 / 不可以被继承的属性"></a>CSS中可以 / 不可以被继承的属性</h2><ul>
<li><p><strong>字体属性：</strong></p>
<p><code>font-family, font-size, font-style, font-variant, font-weight, font</code></p>
</li>
<li><p><strong>文本属性</strong>：</p>
<p><code>word-spacing letter-spacing text-align text-transform text-indent line-height</code>可以继承</p>
<p><em>text-decoration vertical-align不可继承</em></p>
</li>
<li><p><strong>颜色背景属性</strong>：</p>
<p><code>color</code>可以继承</p>
<p><code>background</code>不可继承</p>
</li>
<li><p><strong>边框属性：</strong></p>
<p><code>border</code>不可以继承</p>
<p><code>(border-top border-right border-bottom border-left)(border-width border-style border-color)</code></p>
</li>
<li><p><strong>定位和布局属性：</strong></p>
<p><code>margin padding width height float clear position left top overflow z-index display</code>不可以继承</p>
</li>
<li><p><strong>列表属性：</strong></p>
<p><code>list-style-image, list-style-position,list-style-type, list-style</code>可以继承</p>
</li>
<li><p><strong>所有元素可继承</strong>： </p>
<p><code>visibility和cursor</code></p>
</li>
</ul>
<h2 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CSS3实现圆角（border-radius），阴影（box-shadow），</div><div class="line">对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</div><div class="line">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</div><div class="line">增加了更多的CSS选择器  多背景 rgba </div><div class="line">在CSS3中唯一引入的伪元素是::selection.</div><div class="line">媒体查询，多栏布局(columns属性) </div><div class="line">border-image</div></pre></td></tr></table></figure>
<h2 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</h2><p>HTML5 主要是关于图像，位置，存储，多任务等功能的增加。</p>
<ul>
<li><p>拖拽释放(Drag and drop) API </p>
<p>语义化更好的内容标签（header,nav,footer,aside,article,section）</p>
<p>音频、视频API(audio,video)</p>
<p>画布(Canvas) API</p>
<p>地理(Geolocation) API</p>
<p>本地离线存储 localStorage /sessionStorage</p>
<p>表单控件，calendar、date、time、email、url、search  </p>
<p>新的技术webworker, websocket, Geolocation</p>
</li>
<li><p>移除的元素</p>
<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p>
<p>对可用性产生负面影响的元素：frame，frameset，noframes；</p>
</li>
<li><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签。浏览器支持新标签后，还需要添加标签默认的样式：</p>
</li>
<li><p>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</p>
<!--[if lt IE 9]> 
<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script> 
<![endif]--> 
</li>
</ul>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol>
<li><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</li>
<li>​</li>
</ol>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li><p>修改window.domain 方式(同源跨域)</p>
</li>
<li><p>jsonp</p>
<p>利用js脚本的src属性发送一个get请求，如果没有jjsonp，会正常返回一个json数据，利用jsonp服务端接受callback参数，用该参数包装要返回的json数据，如果我们的页面正好有一个callback的函数，一返回结果就会执行该函数。</p>
</li>
<li><p>postmessage</p>
<p>HTML5新特性，可以完成jsonp无法完成的post请求</p>
<p>A给B跨域发送：<code>iframeWin.postMessage(&#39;hello world!&#39;,&quot;*&quot;);</code>//限制接收窗体的url</p>
<p>B监听发送来的消息：<code>window.addEventListener(&#39;message&#39;, onMessage, false);</code></p>
</li>
<li><p>代理</p>
</li>
<li><p>cors</p>
<p><strong>Access-Control-Allow-Origin</strong></p>
</li>
</ol>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul>
<li><p>同步任务都在主线程上执行，形成一个执行栈。</p>
</li>
<li><p>异步任务不进入主线程，而是进入任务队列</p>
</li>
<li><p>同步——》异步——》回调</p>
<p>先执行同步代码，for，但不给settimeout传参（回调最后执行），等for循环执行完传参。</p>
<p>回调放进消息队列。每执行一次for循环，就放一个settimeout到消息队列中排队。同步执行完了再去调用消息队列中的回调方法。</p>
</li>
</ul>
<h2 id="web性能优化"><a href="#web性能优化" class="headerlink" title="web性能优化"></a>web性能优化</h2><ol>
<li><p>减少http请求：合并css、js，合并图片（css sprites），图片多的时候用延迟加载lazyload（判断在视口中的位置，给img标签填充src属性，jquery有lazyload插件）</p>
</li>
<li><p>开启Gzip。是一种压缩技术，可以将资源在服务端进行压缩，然后发送给浏览器后再进行解压，这种方式会降低传输大小，提高网页加载性能。</p>
</li>
<li><p>按需加载资源。</p>
<p>资源（特别是图片）的按需加载或者说<em>惰性加载</em>，可以有助于你的 Web 应用在整体上获得更好的性能。对于使用大量图片的页面来说惰性加载有着显著的三个好处：</p>
<ul>
<li>减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间）</li>
<li>减少浏览器的内存使用率（更少的图片，更少的内存）</li>
<li>减少服务器端的负载</li>
</ul>
</li>
<li><p>少操作dom，dom的变化（改变文字大小，窗口大小，内容改变，属性改变等）可能会让浏览器重新计算元素的宽高，会引起页面reflow也就是重新布局，过于频繁cpu使用就会上涨</p>
<p>通过设置class，包含有动画属性的元素是否可以采用absolute或者fixed的布局，少进行对dom的查询修改，尤其是少进行对dom的循环操作，总之就是减少reflow的影响范围。</p>
<p>reflow何时发生：</p>
<p>1、添加或者删除可见的DOM元素；</p>
<p>2、元素位置改变；</p>
<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>
<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>
<p>5、页面渲染初始化；</p>
<p>6、浏览器窗口尺寸改变——resize事件发生时；</p>
<p>很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，</p>
<p><strong>直接改变className</strong></p>
<p><strong>不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存</strong></p>
<p>reflow的开销大于repaint,所以用marginLeft, width ,height等属性改变dom时我们要注意减少影响的范围。基本原则就是，把动画元素用position:absolute踢出文档流，这样R&amp;R就限制在了absolute元素的子节点。</p>
</li>
<li><p>用json进行数据交换：js的原生格式，轻量，相比xml的数据体积要小。处理json:eval()和json.parse()</p>
</li>
<li><p>html的语义化，正确使用常用标签：css没有成功加载时呈现好的内容结构；利于SEO</p>
</li>
<li><p>css选择器，从右向左匹配，!important标签、伪类，类型选择器</p>
</li>
<li><p>CDN：网络各处都放置了节点服务器，根据网络流量、各节点负载，到用户的距离把用户的请求重定向到离用户最近的服务节点上。</p>
</li>
<li><p>js和css压缩：减少文件体积</p>
</li>
</ol>
<h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>衡量方法：排序前两个相等的数排序后的位置是否颠倒。如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<ol>
<li><p>冒泡、插入、归并</p>
<p>稳定</p>
</li>
<li><p>选择排序、快排</p>
<p>每个位置选当前元素最小的。不稳定</p>
</li>
</ol>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Copy(p, c) &#123;</div><div class="line">      var c = c || &#123;&#125;;</div><div class="line">      for (var i in p) &#123;</div><div class="line">      　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">      　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">      　　　　　Copy(p[i], c[i]);</div><div class="line">      　　&#125; else &#123;</div><div class="line">      　　　　　c[i] = p[i];</div><div class="line">      　　&#125;</div><div class="line">      &#125;</div><div class="line">      return c;</div><div class="line">&#125; </div><div class="line">var a=&#123;&#125;;  </div><div class="line">  a.key2 = [&apos;小辉&apos;,&apos;小辉&apos;];</div><div class="line">  var b=&#123;&#125;;</div><div class="line">  b = Copy(a,b);        </div><div class="line">  b.key2.push(&quot;大辉&quot;);</div><div class="line">  alert(b.key2);    //小辉，小辉，大辉</div><div class="line">  alert(a.key2);    //小辉，小辉</div></pre></td></tr></table></figure>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function getInfo() &#123;</div><div class="line">        //创建ajax请求对象</div><div class="line">        var req;</div><div class="line">        if (window.XMLHttpRequest) &#123;</div><div class="line">           req = new XMLHttpRequest();</div><div class="line">        &#125;else&#123;</div><div class="line">            req = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">        &#125;        </div><div class="line">        req.open(&quot;get&quot;, &quot;server.json&quot;);</div><div class="line">        //发送请求</div><div class="line">        req.send();</div><div class="line"></div><div class="line">        req.onreadystatechange = function () &#123;</div><div class="line">            if (req.readyState === 4) &#123;</div><div class="line">                if (req.status === 200) &#123;</div><div class="line">                    success(req.responseText);</div><div class="line">                &#125; else &#123;</div><div class="line">                    error(req.status);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    function success(responseText) &#123;</div><div class="line">        // alert(responseText);</div><div class="line">        var obj = JSON.parse(responseText);</div><div class="line">        $(&quot;#name&quot;).val(obj[&quot;name&quot;]);</div><div class="line">        $(&quot;#age&quot;).val(obj[&quot;age&quot;]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function error(status) &#123;</div><div class="line">        $(&quot;#info&quot;).text(&quot;error&quot; + status);</div><div class="line">    &#125;</div><div class="line">    $(&quot;button&quot;).on(&quot;click&quot;, getInfo);</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/14/基础补漏/" data-id="cj4c4j8s4000lvm2yzx8bvkpe" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Doctype、标准模式与兼容模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/13/Doctype、标准模式与兼容模式/" class="article-date">
  <time datetime="2017-01-13T09:12:30.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/Doctype、标准模式与兼容模式/">Doctype、标准模式与兼容模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Doctype：让浏览器知道是标准模式还是兼容模式</p>
</blockquote>
<p>指示浏览器用什么文档标准去解析文档；（这个html是根据什么标准写的，4还是5）</p>
<p>html4要引用DTD，是因为html4基于<code>SGML</code>:标准通用标记语言，而h5不基于SGML，因此不需要引用。<br>SGML是比HTML、XML还要古老的标准，这两者都是由SGML发展而来。</p>
<p>如果Doctype不存在，文档就会以兼容模式呈现。</p>
<blockquote>
<p>标准模式&amp;兼容模式（怪异模式）</p>
</blockquote>
<p>标准模式会以该浏览器支持的最高标准来运行；<br>兼容模式会向后兼容，模拟老浏览器的行为以防止站点无法工作。</p>
<ol>
<li>盒模型的处理差异：<br>标准css盒的宽度是内容的宽度；<br>而IE6之前的盒模型宽度是<strong>内容宽度+padding+border</strong>；</li>
<li>行内元素的垂直对齐：<br>标准模式下图片与文字对齐至基线，图片与父元素的下边框之间会有空隙；<br>怪异模式下对齐到底部</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/13/Doctype、标准模式与兼容模式/" data-id="cj4c4j8r60001vm2yvdetb8sa" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hexo配置过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/09/Hexo配置过程/" class="article-date">
  <time datetime="2017-01-09T12:19:19.000Z" itemprop="datePublished">2017-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/09/Hexo配置过程/">Hexo配置过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一次搭建Hexo，总结一下整个过程：</p>
<blockquote>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3></blockquote>
<ol>
<li>安装<code>Node.js</code>：<br>Hexo是一款基于<code>Node.js</code>的静态博客框架，可以用来生成静态页面</li>
<li>安装<code>git</code>：把本地的hexo内容push到github上去<br>git的具体使用可以参见<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰</a>的博客，写得很详细</li>
<li>申请github账号</li>
</ol>
<blockquote>
<h3 id="安装搭建Hexo"><a href="#安装搭建Hexo" class="headerlink" title="安装搭建Hexo"></a>安装搭建Hexo</h3></blockquote>
<ol>
<li>安装Hexo<br>进入<code>gitbash</code>执行以下命令：<br><code>$ npm install -g hexo</code><br>安装hexo插件，可以让hexo通过<code>git</code>发布<br><code>$ npm install --save hexo-deployer-git</code></li>
<li>创建一个Hexo项目<br>选择本地磁盘创建Hexo文件夹，进入该目录后右键<code>gitbash</code>：<br><code>$ hexo init</code><br>生成静态页面<br><code>$ hexo g</code><br>启动hexo服务器<br><code>$ hexo s</code><br>至此本地hexo创建成功，访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>即可看到漂亮的博客界面，默认监听4000端口。</li>
</ol>
<blockquote>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3></blockquote>
<ol>
<li>建立<code>Repository</code><br>在github个人主页新建repository，仓库名必须为：<strong>用户名.github.io</strong></li>
<li><p>配置<code>_config.yml</code><br>该文件在本地磁盘创建的hexo目录下，翻到最底部，修改如下（注意冒号后的空格）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy: </div><div class="line">  type: git   #有的版本是github也是个小坑，注意</div><div class="line">  repository: https://github.com/CheyenneRowe/CheyenneRowe.github.io.git</div><div class="line">  #在github仓库中直接复制过来，换成自己的</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
</li>
<li><p>修改后执行：<br><code>$ hexo d</code><br>执行完毕后访问<strong>用户名.github.io</strong>即可看到部署在github上的默认博客，第一次发布可能会有10分钟的延迟。</p>
<p><strong>到这里，你的hexo博客就建好啦~~</strong></p>
</li>
</ol>
<blockquote>
<h3 id="在博客中添加文章："><a href="#在博客中添加文章：" class="headerlink" title="在博客中添加文章："></a>在博客中添加文章：</h3></blockquote>
<ol>
<li>新建文章：<br><code>$ hexo new &quot;文章名&quot;</code></li>
<li>在本地hexo目录–&gt;source–&gt;_posts下出现了“文章名.md”，使用<code>notepad++</code>打开，用<code>markdown</code>语法写完保存。</li>
<li>gitbash中执行：<br><code>$ hexo g -d</code> #生成静态页面，部署到<code>github</code><br><code>$ hexo s</code> #启动server</li>
</ol>
<blockquote>
<p>访问github个人主页，结束！<br>ps:这里贴一个<a href="http://www.tuicool.com/articles/zeIZJzv" target="_blank" rel="external">替换hexo主题</a>的帖子，祝顺利啦~</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/09/Hexo配置过程/" data-id="cj4c4j8r90003vm2y442j08vc" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-html5中一般的结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/03/html5中一般的结构/" class="article-date">
  <time datetime="2017-01-03T07:58:20.000Z" itemprop="datePublished">2017-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/03/html5中一般的结构/">html5中一般的结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>html5针对更好的语义化引入了一些新的标签，以后结构大概按照这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;  </div><div class="line">&lt;html lang=&quot;en&quot;&gt;  </div><div class="line">&lt;head&gt;  </div><div class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;  </div><div class="line">&lt;title&gt;Using main&lt;/title&gt;  </div><div class="line">&lt;/head&gt;  </div><div class="line">&lt;body&gt;  </div><div class="line">    &lt;header&gt;My page&lt;/header&gt;  </div><div class="line">    &lt;nav&gt;  </div><div class="line">        [url=#]Home[/url]  </div><div class="line">    &lt;/nav&gt;  </div><div class="line">    &lt;main&gt;</div><div class="line">   		&lt;h1&gt;Skateboards&lt;/h1&gt;  </div><div class="line">        &lt;article&gt;  </div><div class="line">            &lt;h2&gt;My article&lt;/h2&gt;  </div><div class="line">            Content  </div><div class="line">        &lt;/article&gt;  </div><div class="line">        &lt;aside&gt;  </div><div class="line">            More information  </div><div class="line">        &lt;/aside&gt;  </div><div class="line">    &lt;/main&gt;  </div><div class="line">    &lt;footer&gt;Copyright 2017&lt;/footer&gt;  </div><div class="line">&lt;/body&gt;  </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/03/html5中一般的结构/" data-id="cj4c4j8ro000avm2y0fyindi5" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 10px;">css</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/05/13/js中的继承/">js中的继承</a>
          </li>
        
          <li>
            <a href="/2017/05/13/页面是如何呈现的/">页面是如何呈现的</a>
          </li>
        
          <li>
            <a href="/2017/05/13/重绘-回流是什么/">重绘&amp;回流是什么</a>
          </li>
        
          <li>
            <a href="/2017/05/11/移动web/">移动web</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>