<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>基础补漏 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="适配移动端 固定高度，宽度自适应 12&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;水平方向百分百，flex，定值都可以，不用管手机屏幕的尺寸  固定宽度，viewport缩放 设计图、页面宽度、viewport width使用一个宽度，浏览器帮我们完成缩放。">
<meta property="og:type" content="article">
<meta property="og:title" content="基础补漏">
<meta property="og:url" content="http://yoursite.com/2017/01/14/基础补漏/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="适配移动端 固定高度，宽度自适应 12&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;水平方向百分百，flex，定值都可以，不用管手机屏幕的尺寸  固定宽度，viewport缩放 设计图、页面宽度、viewport width使用一个宽度，浏览器帮我们完成缩放。">
<meta property="og:updated_time" content="2017-05-14T15:03:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础补漏">
<meta name="twitter:description" content="适配移动端 固定高度，宽度自适应 12&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;水平方向百分百，flex，定值都可以，不用管手机屏幕的尺寸  固定宽度，viewport缩放 设计图、页面宽度、viewport width使用一个宽度，浏览器帮我们完成缩放。">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-基础补漏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/14/基础补漏/" class="article-date">
  <time datetime="2017-01-14T14:58:03.000Z" itemprop="datePublished">2017-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      基础补漏
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="适配移动端"><a href="#适配移动端" class="headerlink" title="适配移动端"></a>适配移动端</h2><ol>
<li><p>固定高度，宽度自适应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</div><div class="line">水平方向百分百，flex，定值都可以，不用管手机屏幕的尺寸</div></pre></td></tr></table></figure>
</li>
<li><p>固定宽度，viewport缩放</p>
<p>设计图、页面宽度、viewport width使用一个宽度，浏览器帮我们完成缩放。单位使用px即可。</p>
<p>根据屏幕宽度来动态生成<code>viewport</code>，动态生成缩放比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=640,initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>宽度使用rem</p>
<p>即给<code>&lt;html&gt;</code>设置<code>font-size</code></p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>原型是什么？</strong></p>
<p>在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。</p>
<p><strong>原型链是什么？</strong></p>
<p>JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p>
<p><strong>继承方式：</strong></p>
<ol>
<li><p>原型链</p>
<p><code>Sub.prototype = new Super();</code></p>
<p>缺点：所有子类实例共享继承来的引用属性。</p>
</li>
<li><p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Sub(val)&#123;</div><div class="line">    Super.call(this, val);   // 核心</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：没有用到原型啊，每个子类都有一个新的foo函数，影响性能，浪费内存，冗余。</p>
</li>
<li><p>组合继承（常用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Sub()&#123;</div><div class="line">    Super.call(this);   // 核心</div><div class="line">&#125;</div><div class="line">Sub.prototype = new Super();    // 核心</div></pre></td></tr></table></figure>
<p>构造函数里定义实例属性，原型上绑定函数（实现了函数复用）</p>
<p>优点：</p>
<ul>
<li>调用父类构造方法–&gt; 继承父类的基本属性，并且可以传参</li>
<li>子类原型指向父类实例–&gt;  实现函数复用。</li>
</ul>
<p>缺点：</p>
<ul>
<li>父类构造函数被调用了两次，内存浪费</li>
</ul>
</li>
<li><p>寄生组合继承（优化）</p>
</li>
</ol>
<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>第一步：渲染引擎开始解析html，根据标签构建DOM节点<br>第二步：根据css样式构建渲染树，包括元素的大小、颜色，隐藏的元素不会被构建到该树中。<br>第三步：根据css样式构建布局树，主要是确定元素要显示的位置。<br>第四步：根据前面的信息，绘制渲染树。</p>
<h2 id="cookies，sessionStorage-和-localStorage"><a href="#cookies，sessionStorage-和-localStorage" class="headerlink" title="cookies，sessionStorage 和 localStorage"></a>cookies，sessionStorage 和 localStorage</h2><ul>
<li><p>相同点：存储在客户端</p>
</li>
<li><p><strong>不同点：</strong></p>
<ol>
<li><p>存储大小</p>
<p>cookie数据大小不能超过4k。</p>
<p>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
</li>
<li><p>有效时间</p>
<p>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</p>
<p>cookie  设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
</li>
<li><p>数据与服务器之间的交互方式</p>
<p>cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</p>
<p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
</li>
</ol>
</li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><ol>
<li><p>html：H5新标签在IE9以下的浏览器识别 </p>
<!--[if lt IE 9]>

 <script type="text/javascript" src="js/html5shiv.js"></script>

<![endif]-->
</li>
</ol>
<p>2.css样式的兼容性：</p>
<ul>
<li><p>css的hack问题：主要针对IE的不同版本，不同的浏览器的写法不同       </p>
<p>IE的条件注释hack：       </p>
<!--[if IE 6]>此处内容只有IE6.0可见<![endif]-->          
<!--[if IE 7]>此处内容只有IE7.0可见<![endif]-->
</li>
<li><p>被点击过后的超链接不再具有hover和active属性 </p>
<p>解决办法:按lvha的顺序书写css样式，</p>
<p>“:<strong>l</strong>ink”: a标签还未被访问的状态；</p>
<p>“:<strong>v</strong>isited”: a标签已被访问过的状态；</p>
<p>“:<strong>h</strong>over”: 鼠标悬停在a标签上的状态；</p>
<p>“:<strong>a</strong>ctive”: a标签被鼠标按着时的状态；</p>
</li>
</ul>
<p>3.JavaScript的兼容性</p>
<ul>
<li><p>标准的事件绑定方法函数为addEventListener，但IE下是attachEvent</p>
</li>
<li><p>事件的捕获方式不一致。标准浏览器是由外至内，而IE是由内到外，主流是冒泡。</p>
</li>
<li><p>ajax的实现方式不同，这个我所理解的是获取XMLHttpRequest的不同，IE下是activeXObject</p>
</li>
<li><p>获得DOM节点的父节点、子节点的方式不同</p>
<p>其他浏览器：parentNode  parentNode.childNodes </p>
<p>IE：parentElement parentElement.children</p>
</li>
</ul>
<h2 id="页面是如何呈现的"><a href="#页面是如何呈现的" class="headerlink" title="页面是如何呈现的"></a>页面是如何呈现的</h2><p>1，浏览器首先会查询本机的系统，获取主机名对应的IP地址。</p>
<p>2，若本机查询不到相应的IP地址，则会发起DNS请求，获取主机名对应的IP地址。</p>
<p>3，使用查询到的IP地址，直接访问目标服务器。　</p>
<p>4，浏览器发送HTTP请求。</p>
<p>　　HTTP请求由三部分组成，分别是：请求行、消息报头、请求正文</p>
<p>5， 从请求信息中获得客户机想访问的主机名。</p>
<p>6，从请求信息中获取客户机想要访问的web应用。（web应用程序指提供浏览器访问的程序，简称web应用）</p>
<p>7，从请求信息中获取客户机要访问的web资源。（web资源，即各种文件，图片，视频，文本等）</p>
<p>8，读取相应的主机下的web应用，web资源。</p>
<p>9，用读取到的web资源数据，创建一个HTTP响应。</p>
<p>10，服务器回送HTTP响应。</p>
<p>　　HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p>
<p>11，客户浏览器解析回送的资源，并显示结果。</p>
<h2 id="简述-JS-drag-事件以及模拟-drag-事件的方案"><a href="#简述-JS-drag-事件以及模拟-drag-事件的方案" class="headerlink" title="简述 JS drag 事件以及模拟 drag 事件的方案"></a>简述 JS drag 事件以及模拟 drag 事件的方案</h2><p>一个完整的 drag and drop 流程通常包含以下几个步骤:</p>
<ol>
<li>设置可拖拽目标. 设置属性 draggable=”true” 实现元素的可拖拽.</li>
<li>监听 dragstart 设置拖拽数据</li>
<li>为拖拽操作设置反馈图标 (可选)</li>
<li>设置拖放效果, 如 copy, move, link</li>
<li>设置拖放目标, 默认情况下浏览器阻止所有的拖放操作, 所以需要监听 dragenter 或者 dragover 取消浏览器默认行为使元素可拖放.</li>
<li>监听 drop 事件执行所需操作</li>
</ol>
<p>实现 drag</p>
<ol>
<li>onmousedown + onmousemove → startDrag()</li>
<li>onmouseup → stopDrag()</li>
<li>偏移值，两次事件的鼠标位置记录： e.pageX || e.clientX + scrollX; e.pageY || e.clientY + scrollY;</li>
</ol>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型有两种，W3C和IE盒子模型</p>
<p>W3C定义的盒子模型包括margin、border、padding、content ，元素的width=content的宽度，IE盒子模型与W3C的盒子模型唯一区别就是元素的宽度，元素的width=content+padding+border。</p>
<p>我个人认为IE定义的比较合理，元素的宽度应该包含border（边框）和padding（填充），这个和我们现实生活的盒子是一样的，W3C也认识到自己的问题了，所以在CSS3中新增了一个样式box-sizing，包含两个属性content-box 和 border-box。</p>
<p>对于行内元素，margin-top和margin-bottom无效，margin-left和margin-right有效</p>
<p>对于相邻的块级元素margin-bottom和margin-top 取值方式</p>
<p>1）都是正数： 取最大值</p>
<p>2）都是负数： 取最小值</p>
<p>3）一正一负： 正负相加</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>所有的定位如果left、top、right、bottom属性都为默认值，则为默认定位</p>
<p>absolute定位会脱离文档，浮动起来</p>
<p>absolute定位忽略父元素的padding</p>
<h2 id="样式导入-link-amp-import"><a href="#样式导入-link-amp-import" class="headerlink" title="样式导入 link &amp; import"></a>样式导入 link &amp; import</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;  </div><div class="line"></div><div class="line">&lt;style type=&quot;text/css&quot;&gt;  </div><div class="line">@import &quot;index.css&quot;;  </div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>不同：</p>
<ul>
<li>link除了引用样式文件，还可以引用图片等资源文件，而import只引用样式文件</li>
<li>兼容性不同，link不存在兼容性的问题，import在IE5以上支持，是css2.1新增的</li>
<li>在样式表文件可以使用import导入其它的样式表文件，而link不可以</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。<br>注意：<br>import的写法比较多，引号，url（推荐）</li>
</ul>
<h2 id="伪类-amp-伪元素"><a href="#伪类-amp-伪元素" class="headerlink" title="伪类&amp;伪元素"></a>伪类&amp;伪元素</h2><table>
<thead>
<tr>
<th>伪类</th>
<th>伪元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>:active</td>
<td>::first-letter</td>
</tr>
<tr>
<td>:focus</td>
<td>::first-line</td>
</tr>
<tr>
<td>:hover</td>
<td>::before</td>
</tr>
<tr>
<td>:link</td>
<td>::after</td>
</tr>
<tr>
<td>:visited</td>
<td>::selection</td>
</tr>
<tr>
<td>:first-child</td>
</tr>
</tbody>
</table>
<p>伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p>
<p><code>css3</code> 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。</p>
<h2 id="css选择器的优先级"><a href="#css选择器的优先级" class="headerlink" title="css选择器的优先级"></a>css选择器的优先级</h2><p>顺序：!important &gt; style &gt; 权重值</p>
<p><strong>权重规则</strong></p>
<ul>
<li>标签：1</li>
<li>class：10</li>
<li>id：100</li>
</ul>
<h2 id="元素居中"><a href="#元素居中" class="headerlink" title="元素居中"></a>元素居中</h2><blockquote>
<p>元素水平居中</p>
</blockquote>
<ul>
<li><p>行内元素：父元素设置<code>text-align:center;</code></p>
</li>
<li><p>块级元素：<code>maigin:0 auto;</code>（父元素定宽）</p>
</li>
<li><p>浮动元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">position:relative;</div><div class="line">left:50%;   </div><div class="line">transform: translate(-50%,-50%);</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>元素垂直居中</p>
</blockquote>
<ul>
<li><p>行内元素：height和line-hight一样</p>
</li>
<li><p>块级元素：</p>
<ol>
<li><p>父元素<code>display:table-cell;vertical-align:middle;</code></p>
</li>
<li><p>父元素高度确定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.outer&#123;  </div><div class="line">    width: 500px;  </div><div class="line">    height:300px;  </div><div class="line">    line-height: 300px;  +++</div><div class="line">&#125;  </div><div class="line"> .inner&#123;  </div><div class="line">     background: blue;  </div><div class="line">     width: 300px;  </div><div class="line">     height: 100px;  </div><div class="line">     display: inline-block;  +++</div><div class="line">     vertical-align: middle;  +++</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>子元素定宽定高：相对父元素定位：left:50%;right:50%;此时位置在中心向右向左偏移了子元素的宽度或高度的一半，用<code>margin-top:-子元素高度/2</code>,<code>margin-left:-子元素宽度/2</code></p>
</li>
<li><p>子元素不定宽高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.center&#123;  </div><div class="line">    width: 500px;  </div><div class="line">    height:300px;   </div><div class="line">    position: relative;</div><div class="line">&#125;  </div><div class="line"> .inner&#123;</div><div class="line">     width:30%;  </div><div class="line">     height:30%;</div><div class="line">     position: absolute; +++</div><div class="line">     left: 0;  +++</div><div class="line">     right: 0;   +++</div><div class="line">     top:0;   +++</div><div class="line">     bottom: 0;   +++</div><div class="line">     margin: auto;   +++</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
</li>
</ul>
<h2 id="块元素与行内元素"><a href="#块元素与行内元素" class="headerlink" title="块元素与行内元素"></a>块元素与行内元素</h2><ul>
<li>块元素：<code>div/p/ul/ol/dl/table/form/blockquote/h1-h6/</code></li>
<li>行内元素：<code>a/abbr/br/cite/em/i/img/input/label/select/span/strong/sub/sup/textarea/u</code></li>
</ul>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>更严谨的说法其实是叫“闭合浮动”：主要是解决元素浮动后父元素高度塌陷的问题。</p>
<ul>
<li>添加额外标签</li>
<li>给container添加overflow属性</li>
<li>container也浮动</li>
<li>::after伪元素</li>
</ul>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>从页面接收事件的顺序，起初：</p>
<ul>
<li><p>IE：事件冒泡流(主流)</p>
<ul>
<li>button -&gt; body -&gt; document -&gt; window</li>
</ul>
</li>
<li><p>事件流，包括三个阶段：</p>
<ul>
<li><p>事件捕获阶段</p>
<ul>
<li>addEventListener最后一个参数，true代表事件捕获模式，<strong>false表示事件冒泡模式</strong>(默认)。</li>
</ul>
</li>
<li><p>处于目标阶段</p>
<ul>
<li>事件到了具体元素，被看成冒泡阶段的一部分</li>
</ul>
</li>
<li><p>事件冒泡阶段</p>
<p>可以被阻止：</p>
<ol>
<li>IE模型，<code>window.event.cancelBubble = true</code></li>
<li>w3c模型：<code>e.stopPropagation()</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="DOM0级、DOM2事件处理程序"><a href="#DOM0级、DOM2事件处理程序" class="headerlink" title="DOM0级、DOM2事件处理程序"></a>DOM0级、DOM2事件处理程序</h3><ol>
<li><p>Dom0级：事件流的冒泡阶段被处理</p>
<p><code>btn.onclick=function(){};</code></p>
</li>
<li><p>Dom2级：true捕获</p>
<p><code>addEventListener(事件名，处理函数，bool)</code>和<code>removeEventListener(事件名，处理函数，bool)</code></p>
<p>主流都是在冒泡阶段调用事件处理程序，所以默认为<code>false</code>, <code>true</code>表示捕获阶段调用。</p>
</li>
</ol>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>将事件委托到父元素或祖先元素来实现。</p>
<ol>
<li><p>一一添加事件监听麻烦</p>
<p>当我们想要给一系列元素添加一些事件，又不想对每个元素一一去添加事件监听时，可以采用委托来实现。</p>
</li>
<li><p>委托可以有效的提高页面性能。</p>
<p>给大量元素都添加事件监听时，会照成页面过多的性能损耗，所以碰到要给一系列元素添加事件时，建议采用事件委托，</p>
</li>
</ol>
<h2 id="CSS中可以-不可以被继承的属性"><a href="#CSS中可以-不可以被继承的属性" class="headerlink" title="CSS中可以 / 不可以被继承的属性"></a>CSS中可以 / 不可以被继承的属性</h2><ul>
<li><p><strong>字体属性：</strong></p>
<p><code>font-family, font-size, font-style, font-variant, font-weight, font</code></p>
</li>
<li><p><strong>文本属性</strong>：</p>
<p><code>word-spacing letter-spacing text-align text-transform text-indent line-height</code>可以继承</p>
<p><em>text-decoration vertical-align不可继承</em></p>
</li>
<li><p><strong>颜色背景属性</strong>：</p>
<p><code>color</code>可以继承</p>
<p><code>background</code>不可继承</p>
</li>
<li><p><strong>边框属性：</strong></p>
<p><code>border</code>不可以继承</p>
<p><code>(border-top border-right border-bottom border-left)(border-width border-style border-color)</code></p>
</li>
<li><p><strong>定位和布局属性：</strong></p>
<p><code>margin padding width height float clear position left top overflow z-index display</code>不可以继承</p>
</li>
<li><p><strong>列表属性：</strong></p>
<p><code>list-style-image, list-style-position,list-style-type, list-style</code>可以继承</p>
</li>
<li><p><strong>所有元素可继承</strong>： </p>
<p><code>visibility和cursor</code></p>
</li>
</ul>
<h2 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CSS3实现圆角（border-radius），阴影（box-shadow），</div><div class="line">对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</div><div class="line">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</div><div class="line">增加了更多的CSS选择器  多背景 rgba </div><div class="line">在CSS3中唯一引入的伪元素是::selection.</div><div class="line">媒体查询，多栏布局(columns属性) </div><div class="line">border-image</div></pre></td></tr></table></figure>
<h2 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</h2><p>HTML5 主要是关于图像，位置，存储，多任务等功能的增加。</p>
<ul>
<li><p>拖拽释放(Drag and drop) API </p>
<p>语义化更好的内容标签（header,nav,footer,aside,article,section）</p>
<p>音频、视频API(audio,video)</p>
<p>画布(Canvas) API</p>
<p>地理(Geolocation) API</p>
<p>本地离线存储 localStorage /sessionStorage</p>
<p>表单控件，calendar、date、time、email、url、search  </p>
<p>新的技术webworker, websocket, Geolocation</p>
</li>
<li><p>移除的元素</p>
<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p>
<p>对可用性产生负面影响的元素：frame，frameset，noframes；</p>
</li>
<li><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签。浏览器支持新标签后，还需要添加标签默认的样式：</p>
</li>
<li><p>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</p>
<!--[if lt IE 9]> 
<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script> 
<![endif]--> 
</li>
</ul>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol>
<li><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</li>
<li>​</li>
</ol>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li><p>修改window.domain 方式(同源跨域)</p>
</li>
<li><p>jsonp</p>
<p>利用js脚本的src属性发送一个get请求，如果没有jjsonp，会正常返回一个json数据，利用jsonp服务端接受callback参数，用该参数包装要返回的json数据，如果我们的页面正好有一个callback的函数，一返回结果就会执行该函数。</p>
</li>
<li><p>postmessage</p>
<p>HTML5新特性，可以完成jsonp无法完成的post请求</p>
<p>A给B跨域发送：<code>iframeWin.postMessage(&#39;hello world!&#39;,&quot;*&quot;);</code>//限制接收窗体的url</p>
<p>B监听发送来的消息：<code>window.addEventListener(&#39;message&#39;, onMessage, false);</code></p>
</li>
<li><p>代理</p>
</li>
<li><p>cors</p>
<p><strong>Access-Control-Allow-Origin</strong></p>
</li>
</ol>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul>
<li><p>同步任务都在主线程上执行，形成一个执行栈。</p>
</li>
<li><p>异步任务不进入主线程，而是进入任务队列</p>
</li>
<li><p>同步——》异步——》回调</p>
<p>先执行同步代码，for，但不给settimeout传参（回调最后执行），等for循环执行完传参。</p>
<p>回调放进消息队列。每执行一次for循环，就放一个settimeout到消息队列中排队。同步执行完了再去调用消息队列中的回调方法。</p>
</li>
</ul>
<h2 id="web性能优化"><a href="#web性能优化" class="headerlink" title="web性能优化"></a>web性能优化</h2><ol>
<li><p>减少http请求：合并css、js，合并图片（css sprites），图片多的时候用延迟加载lazyload（判断在视口中的位置，给img标签填充src属性，jquery有lazyload插件）</p>
</li>
<li><p>开启Gzip。是一种压缩技术，可以将资源在服务端进行压缩，然后发送给浏览器后再进行解压，这种方式会降低传输大小，提高网页加载性能。</p>
</li>
<li><p>按需加载资源。</p>
<p>资源（特别是图片）的按需加载或者说<em>惰性加载</em>，可以有助于你的 Web 应用在整体上获得更好的性能。对于使用大量图片的页面来说惰性加载有着显著的三个好处：</p>
<ul>
<li>减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间）</li>
<li>减少浏览器的内存使用率（更少的图片，更少的内存）</li>
<li>减少服务器端的负载</li>
</ul>
</li>
<li><p>少操作dom，dom的变化（改变文字大小，窗口大小，内容改变，属性改变等）可能会让浏览器重新计算元素的宽高，会引起页面reflow也就是重新布局，过于频繁cpu使用就会上涨</p>
<p>通过设置class，包含有动画属性的元素是否可以采用absolute或者fixed的布局，少进行对dom的查询修改，尤其是少进行对dom的循环操作，总之就是减少reflow的影响范围。</p>
<p>reflow何时发生：</p>
<p>1、添加或者删除可见的DOM元素；</p>
<p>2、元素位置改变；</p>
<p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p>
<p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>
<p>5、页面渲染初始化；</p>
<p>6、浏览器窗口尺寸改变——resize事件发生时；</p>
<p>很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，</p>
<p><strong>直接改变className</strong></p>
<p><strong>不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存</strong></p>
<p>reflow的开销大于repaint,所以用marginLeft, width ,height等属性改变dom时我们要注意减少影响的范围。基本原则就是，把动画元素用position:absolute踢出文档流，这样R&amp;R就限制在了absolute元素的子节点。</p>
</li>
<li><p>用json进行数据交换：js的原生格式，轻量，相比xml的数据体积要小。处理json:eval()和json.parse()</p>
</li>
<li><p>html的语义化，正确使用常用标签：css没有成功加载时呈现好的内容结构；利于SEO</p>
</li>
<li><p>css选择器，从右向左匹配，!important标签、伪类，类型选择器</p>
</li>
<li><p>CDN：网络各处都放置了节点服务器，根据网络流量、各节点负载，到用户的距离把用户的请求重定向到离用户最近的服务节点上。</p>
</li>
<li><p>js和css压缩：减少文件体积</p>
</li>
</ol>
<h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>衡量方法：排序前两个相等的数排序后的位置是否颠倒。如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<ol>
<li><p>冒泡、插入、归并</p>
<p>稳定</p>
</li>
<li><p>选择排序、快排</p>
<p>每个位置选当前元素最小的。不稳定</p>
</li>
</ol>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Copy(p, c) &#123;</div><div class="line">      var c = c || &#123;&#125;;</div><div class="line">      for (var i in p) &#123;</div><div class="line">      　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">      　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">      　　　　　Copy(p[i], c[i]);</div><div class="line">      　　&#125; else &#123;</div><div class="line">      　　　　　c[i] = p[i];</div><div class="line">      　　&#125;</div><div class="line">      &#125;</div><div class="line">      return c;</div><div class="line">&#125; </div><div class="line">var a=&#123;&#125;;  </div><div class="line">  a.key2 = [&apos;小辉&apos;,&apos;小辉&apos;];</div><div class="line">  var b=&#123;&#125;;</div><div class="line">  b = Copy(a,b);        </div><div class="line">  b.key2.push(&quot;大辉&quot;);</div><div class="line">  alert(b.key2);    //小辉，小辉，大辉</div><div class="line">  alert(a.key2);    //小辉，小辉</div></pre></td></tr></table></figure>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function getInfo() &#123;</div><div class="line">        //创建ajax请求对象</div><div class="line">        var req;</div><div class="line">        if (window.XMLHttpRequest) &#123;</div><div class="line">           req = new XMLHttpRequest();</div><div class="line">        &#125;else&#123;</div><div class="line">            req = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">        &#125;        </div><div class="line">        req.open(&quot;get&quot;, &quot;server.json&quot;);</div><div class="line">        //发送请求</div><div class="line">        req.send();</div><div class="line"></div><div class="line">        req.onreadystatechange = function () &#123;</div><div class="line">            if (req.readyState === 4) &#123;</div><div class="line">                if (req.status === 200) &#123;</div><div class="line">                    success(req.responseText);</div><div class="line">                &#125; else &#123;</div><div class="line">                    error(req.status);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    function success(responseText) &#123;</div><div class="line">        // alert(responseText);</div><div class="line">        var obj = JSON.parse(responseText);</div><div class="line">        $(&quot;#name&quot;).val(obj[&quot;name&quot;]);</div><div class="line">        $(&quot;#age&quot;).val(obj[&quot;age&quot;]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function error(status) &#123;</div><div class="line">        $(&quot;#info&quot;).text(&quot;error&quot; + status);</div><div class="line">    &#125;</div><div class="line">    $(&quot;button&quot;).on(&quot;click&quot;, getInfo);</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/14/基础补漏/" data-id="cj4c4j8s4000lvm2yzx8bvkpe" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/01/20/补漏/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          补漏
        
      </div>
    </a>
  
  
    <a href="/2017/01/13/Doctype、标准模式与兼容模式/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Doctype、标准模式与兼容模式</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 10px;">css</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/05/13/js中的继承/">js中的继承</a>
          </li>
        
          <li>
            <a href="/2017/05/13/页面是如何呈现的/">页面是如何呈现的</a>
          </li>
        
          <li>
            <a href="/2017/05/13/重绘-回流是什么/">重绘&amp;回流是什么</a>
          </li>
        
          <li>
            <a href="/2017/05/11/移动web/">移动web</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>